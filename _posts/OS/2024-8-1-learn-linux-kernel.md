---
layout: post
title: Linux内核学习笔记1
subtitle: 内核学习笔记
banner:
  image: /assets/images/banners/11.jpg
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: underline"
  subheading_style: "color: gold"
tags: OS linux
published: false
---

## 单内核和微内核

&emsp;&emsp;单内核是指将内核作为一个整体的大过程实现，运行在一个单独的地址空间上。在磁盘上以一个单独的二进制文件存储。好处是简单和性能高效。<br>
&emsp;&emsp;微内核是指将内核的功能分成一个个小的服务器，各自保持独立运行在自己的内存空间里。所以，就不能像单内核那样直接调用函数，而是采用进程间通讯IPC机制互通消息。这样的设计保证了一个崩溃了不会殃及全局，并且，内核的组件可以动态改变。但是同样的，IPC占用时间大于函数调用，效率没有单内核高。

> 任何改变都要能通过简洁的设计和可靠的实现来解决现实中确实存在的问题。

## 进程和线程

&emsp;&emsp;进程是指处于执行期的程序以及其它资源的总称。线程是在进程中活动的对象。

- 每个线程都拥有自己独立的程序计数器、进程栈和一组进程寄存器
- 内核的调度对象是线程而不是进程
- 线程之间可以共享虚拟内存，但是每一个都拥有自己的虚拟处理器
- 使用fork创建进程，从内核返回两次，一次是这个函数创建完成，返回调用fork的进程，另一次是返回新进程。
- 进程又称作task

### 进程描述符和任务结构

&emsp;&emsp;内核把进程的列表放在名为任务队列的双向循环链表中，每一项都是类型为`task_struct`，成为进程描述符的结构，该结构能够完整的描述一个正在执行的程序，包括但不限于打开的文件、地址空间等等。该描述符存在内核栈中。Linux2.6以后的版本会在`task_struct`栈底追加`thread_info`

&emsp;&emsp;进程状态有运行、停止、可中断（正在被某种原因阻塞，一旦满足要求就会重新运行）、不可中断（信号阻塞，并且不会被外界打断这种状态，开霸体了）、TRACE跟踪状态。

&emsp;&emsp;进程在自己的内存空间运行，当触发系统调用的时候，称陷入内核空间，内核处于进程上下文中，当然，此时也会听调度器的。

&emsp;&emsp;系统中所有的进程都是PID=1的init进程后代，进程关系存放在`task_struct`中，包含了指向其父进程`task_struct`的指针，也包含了一个`children`子进程链表。由此，如果你愿意，可以一直上溯到1号进程。

&emsp;&emsp;进程创建是将父进程所有资源复制到新的进程空间中，目前使用的方法是`copy-on-write`，就是在新进程需要写入数据之前，和父进程共享资源，当然，是只读的。当需要写入时，再进行资源的复制。

> 这里我不明白，那如果父进程要写入呢？为什么要复制父进程的资源呢？

### `current`宏

&emsp;&emsp;`current`宏：

```c
#define current get_current()

static __always_inline struct task_struct *get_current(void)
{
	if (IS_ENABLED(CONFIG_USE_X86_SEG_SUPPORT))
		return this_cpu_read_const(const_pcpu_hot.current_task);

	return this_cpu_read_stable(pcpu_hot.current_task);
}

#define this_cpu_read_stable(pcp)			__pcpu_size_call_return(this_cpu_read_stable_, pcp)
```

总之就是返回目前正在运行的，也就是现在这个进程的`task_struct`，我觉得类似于cpp的this。在arch/x86/kernel/process_64.c文件中的__switch_to函数中有如下代码：

```c
this_cpu_write(current_task, next_p);  
```

在x86体系结构中，使用了current_task这个每CPU变量，来存储当前正在使用cpu的进程的struct task_struct。 由于采用了每cpu变量current_task来保存当前运行进程的task_struct，所以在进程切换时，就需要更新该变量。

### 进程的结束

&emsp;&emsp;进程的结束包含下列操作：删除内核所有正在运行的定时器、释放空间、释放使用的文件资源（这里有auto_ptr的思想）、调用函数通知父进程，给子进程找养父，养父可以是进程组里面的其他进程，也可以是init进程。最后设置当前进程状态为EXIT_ZOMBIE，即僵尸进程。调度器切换上下文，永不返回，成为僵尸进程。

&emsp;&emsp;此时，所有资源释放已经完毕，唯一占用的空间是描述进程的结构体、内核栈。此时它存在的意义是等着父进程处理。等到父进程通知内核这是无关信息后，所有内存都将被释放。最后的清理称之为删除进程描述符。上一段的删除操作是释放进程资源。

## 进程调度

&emsp;&emsp;多任务系统分为两类：非抢占式和抢占式。抢占式系统中的进程在抢占后使用CPU的时间是被设定好的，成为进程的时间片。非抢占式系统则是需要“物质生活极大丰富（不是），道德水平极大提高”的前提————每个程序都需要主动挂起自己，称之为让步，如果谁不让步，就会一直占着CPU不放，如你所想，一个进入死锁的程序又拒不让步，那么电脑将会崩溃。显然，一个非定制的操作系统这样设计并不明智。不过历史上还真有这样的系统————windows3.1以及MacOS9。

&emsp;&emsp;进程可以被分为两类：IO密集型和计算密集型。前者许多时间用于等待，后者许多时间用于处理。前者的典例比如图形操作界面，他们总是在等待键盘鼠标的输入，经过计算后也总是进入阻塞，再次等待；后者的典例比如正在进行计算的MATLAB程序，甚至不需要什么IO，全部数据已经加载进入内存，需要的只是大规模的计算。当然，这两者也并不总是绝对的，比如带有图形操作界面的MATLAB程序（笑）

### 进程的优先级

&emsp;&emsp;一个朴素的想法就是根据进程的价值和对处理器的需求进行评判。为每一个进程设置优先级，高的先执行，统计轮换执行，高的进程时间片也长，系统总是选择优先级高并且时间片没用完的进程执行。

&emsp;&emsp;一个正在使用的优先级就是nice值。范围是-20~+19，nice值越大，优先级越低；也就是说-20是优先级最高的进程。0是默认的nice值。Mac系统中，nice值决定分配时间片的绝对值大小；Linux系统中，决定了分配时间片的比例（好像也没啥区别，就是写法不一样）。

&emsp;&emsp;另一种优先级系统是实时优先级。范围0~99，越大优先级越高。任何实时进程的优先级都高于普通进程————这意味着这个优先级系统和nice优先级系统泾渭分明。我运行了`ps -eo state,uid,pid,ppid,rtprio`命令，rtprio列下全是‘-’，代表当前没有实时进程。

&emsp;&emsp;可以通过命令指定某个进程为实时进程，以获得更高的优先级。

&emsp;&emsp;显然，调度器必须有一个默认的时间片，太大了让人感觉不是实时并行的，太短了又把时间浪费在切换上下文上。值得记录的是，对于计算密集类的进程，长的时间片可以提高其缓存命中率。一般默认的时间片为10ms。不过，linux系统使用的是比例调度，这样使用时间其实就和系统负载相关了，高nice值能够获得更多的处理器使用比。

&emsp;&emsp;朴素的抢占式：当进程进入可运行状态，立即投入运行。在linux系统中，抢占时机取决于就绪的进程消耗了多少处理器时间比，如果小于正在运行的进程，那么发生抢占。下面是一个实际例子：系统正在运行一个文本编辑器和一个视频编码器，对于前者，我们希望我们键入之后立即反应，对于后者，我们并不关心它是不是立刻运行的，当然，我们希望能够尽早完成编码任务。在百分比的使用调度下，假设二者的nice值都是0，那么二者将均分处理器使用时间。但是，编辑器在处理完输入后，进入等待，也即非可运行状态，从而被编码器抢占；但是当编辑器收到了键入被唤醒之后，因为其使用时间远小于50%，编码器远大于50%，编辑器没有消耗系统承诺的50%时间片，自然触发了抢占。

> 评：真是天才的想法，谁想出来的！不过这样，我们希望IO密集型能够自己挂起，如果不挂起，属于是损人不利己：既让计算密集型没有抢到时间，自己也被等待时间耽误了，下一次触发输入的时候还不能以高优先级抢占。不知道linux是怎么处理这一情况的？
>
> 